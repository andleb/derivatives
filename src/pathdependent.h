/** \file pathdependent.h
 * \author Andrej Leban
 * \date 4/2019
 *
 *
 */

#ifndef PATHDEPENDENT_H
#define PATHDEPENDENT_H

#include <memory>
#include <vector>

namespace der
{

// TODO: * document!

// Forward declarations
class Payoff;

//! \brief The CashFlow struct
struct CashFlow
{
    // no ctors => an aggregation hence can be aggregate-initialized!

    //! \brief The monetary value itself.
    double amount;
    //! \brief Array index to the pre-computed discounts.
    //!  The engine knows in advance about the possible cash-flow times & pre-computes the discounting.
    //!  This member allows us to communicate which element in the series is considered.
    size_t timeIndex;
};

//! \brief The abstract interface for path-dependent options.
class PathDependent
{
public:
    explicit PathDependent(const std::vector<double> & p_lookAtTimes);

    PathDependent(const PathDependent &) = default;
    PathDependent(PathDependent &&) = default;
    PathDependent & operator=(const PathDependent &) = default;
    PathDependent & operator=(PathDependent &&) = default;
    virtual ~PathDependent();

    virtual std::unique_ptr<PathDependent> clone() const = 0;

    //! \brief The times that are relevant to the pay-off function of the product.
    //! This is used, for example, to request spot values from an engine.
    std::vector<double> lookAtTimes() const;

    // C++ 20+ allows for virtual constexpr functions, as would come into play here,
    // since we need virtual for the interface, but an implementation could be constexpr - i.e. an option only pays at the end.
    // Interestingly, Clang 8 allows it even now.

    //! \brief Maximum number of cash-flows.
    //! Used, for example, by an engine to pre-allocate working arrays.
    virtual size_t maxNumberOfCashFlows() const = 0;
    //! \brief Possible times at which cash-flows can be generated.
    //! Used, for example, by an engine to pre-compute discount factors.
    virtual std::vector<double> possibleCashFlowTimes() const = 0;

    // NOTE: returns a modified version of the input, preferring this to input/output params

    //! \brief Contains the cash-flows stemming from the derivative.
    //! \param p_spots
    //! \param p_flows
    //! \return
    virtual std::vector<CashFlow> cashFlows(const std::vector<double> & p_spots, std::vector<CashFlow> && p_flows) const = 0;

protected:
    std::vector<double> m_lookAtTimes;
};

//! \brief An abstract class encapsulating common attributes to all Asian type options.
class AsianOption : public PathDependent
{
public:
    //! \brief AsianOption
    //! \param p_lookAtTimes: the averaging times
    //! \param p_delivery:  the expiry date can be different from the last averaging date
    //! \param p_payoff:    the simple payoff/option this option is composed of, i.e. vanilla call etc.
    AsianOption(const std::vector<double> & p_lookAtTimes, double p_delivery, const Payoff & p_payoff);

    AsianOption(const AsianOption & p_other);
    AsianOption(AsianOption &&) = default;
    AsianOption & operator=(const AsianOption & p_other);
    AsianOption & operator=(AsianOption &&) = default;
    ~AsianOption() override = default;

    size_t maxNumberOfCashFlows() const override;
    std::vector<double> possibleCashFlowTimes() const override;

    // NOTE: these still remain unimplemented:
    // std::unique_ptr<PathDependent> clone() const = 0;
    // std::vector<CashFlow> cashFlows(const std::vector<double> &, std::vector<CashFlow> &&) const = 0;

protected:
    double m_delivery;
    std::unique_ptr<Payoff> m_pPayoff;
};

//! \brief The AsianOptionArith class
//!
class AsianOptionArith : public AsianOption
{
public:
    //! \brief AsianOptionArith
    //! \param p_lookAtTimes: the averaging times
    //! \param p_delivery:  the expiry date can be different from the last averaging date
    //! \param p_payoff:    the simple payoff/option this option is composed of, i.e. vanilla call etc.
    AsianOptionArith(const std::vector<double> & p_lookAtTimes, double p_delivery, const Payoff & p_payoff);

    std::unique_ptr<PathDependent> clone() const override;

    //! \brief The payoff of the arithmetic Asian option at delivery is naturally the arithmetic mean of the
    //! underlying at the times specified. The times specified are baked-in the \p p_spots, which is generated by
    //! the engine implementation according to \p lookAtTimes.
    //! \param p_spots
    //! \param p_flows
    //! \return \p p_flows modified in-place.
    std::vector<CashFlow> cashFlows(const std::vector<double> & p_spots, std::vector<CashFlow> && p_flows) const override;
};

//! \brief The AsianOptionGeom class
//!
class AsianOptionGeom : public AsianOption
{
public:
    //! \brief AsianOptionGeom
    //! \param p_lookAtTimes: the averaging times
    //! \param p_delivery:  the expiry date can be different from the last averaging date
    //! \param p_payoff:    the simple payoff/option this option is composed of, i.e. vanilla call etc.
    AsianOptionGeom(const std::vector<double> & p_lookAtTimes, double p_delivery, const Payoff & p_payoff);

    std::unique_ptr<PathDependent> clone() const override;

    //! \brief The payoff of the geometric Asian option at delivery is naturally the geometric mean of the
    //! underlying at the times specified. The times specified are baked-in the \p p_spots, which is generated by
    //! the engine implementation according to \p lookAtTimes.
    //! \param p_spots
    //! \param p_flows
    //! \return \p p_flows modified in-place.
    std::vector<CashFlow> cashFlows(const std::vector<double> & p_spots, std::vector<CashFlow> && p_flows) const override;
};

} // namespace der

#endif // PATHDEPENDENT_H
